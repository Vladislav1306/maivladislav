#include<opencv2/opencv.hpp>
#include <opencv\cv.h>
#include <opencv2\highgui\highgui.hpp>
#include <opencv2\imgproc\imgproc.hpp>
#include <WinSock2.h>
#include <WS2tcpip.h>
#include <stdio.h>
#include <iostream>
#include <iomanip>

#pragma comment(lib, "Ws2_32.lib")
#define default_buflen 1024
#define default_port "1234"

using namespace std;
using namespace cv;

Mat Filter(Mat &frame, Mat &edge, Mat &filter, Mat &gray_image) {

	cvtColor(frame, gray_image, COLOR_BGR2GRAY);
	GaussianBlur(gray_image, filter, Size(7, 7), 1.5);
	Canny(filter, edge, 50, 150, 3);

	return edge;
}

int Error1(VideoCapture &cap, VideoWriter & oVideoWriter){

	if (!cap.isOpened())
	{
		cout << "Cannot connect to camera" << endl;
		getchar();
		return -1;
	}

	if (!oVideoWriter.isOpened())
	{
		cout << "ERROR: Failed to write the video" << endl;
		return -1;
	}
}

int Error2(VideoCapture& cap, Mat& frame) {

	bool bSuccess = cap.read(frame);

	if (!bSuccess)
	{
		cout << "ERROR: Cannot read a frame from video file" << endl;
		return -1;
	}
}

class Line {

	int RCMx, RCMy, CLx, CLy, rectcentrey, rectcentrex, Distance;

public:
	Line(int RCMX, int RCMY, int CLX, int CLY, int rectcentreY, int rectcentreX, int distance) {

		RCMx = RCMX;
		RCMy = RCMX;
		CLx = CLX;
		CLy = CLY;
		rectcentrey = rectcentreY;
		rectcentrex = rectcentreX;
		Distance = distance;

	}

	int RectCentre(Rect &minRect) {

		rectcentrex = minRect.x + minRect.width / 2;
		rectcentrey = minRect.y + minRect.height / 2;

		return rectcentrey;
		return rectcentrex;
	}

	int Dist() {

		Distance = norm(Point(RCMx, RCMy) - Point(rectcentrex, rectcentrey));

		return Distance;
	}

	int CentreLine() {

		CLx = abs((rectcentrex - RCMx) / 2);
		if (rectcentrex > RCMx)
			CLx = RCMx + CLx;
		else
			CLx = rectcentrex + CLx;
		CLy = abs((rectcentrey - RCMy) / 2);
		if (rectcentrey > RCMy)
			CLy = RCMy + CLy;
		else
			CLy = rectcentrey + CLy;

			return CLy;
			return CLx;

	}

	int Equality() {
		RCMx = rectcentrex;
		RCMy = rectcentrey;

		return RCMx;
		return RCMy;
	}

	int GetrectcentreX() {
		return rectcentrex;
	}

	int GetrectcentreY() {
		return rectcentrey;
	}

	int GetRCMX() {
		return RCMx;
	}

	int GetRCMY() {
		return RCMy;
	}

	int GetCLX() {
		return CLx;
	}

	int GetCLY() {
		return CLy;
	}

	int Getdistance() {
		return Distance;
	}
};

class Area {
	int SP, dWidth, dHeight;
	double Rat, XM, YM, NM;
public:
	Area(double Xm, double Ym, double rat, int sp, int DWidth, int DHeight, double Nm) {

		XM = Xm;
		YM = Ym;
		Rat = rat;
		SP = sp;
		dWidth = DWidth;
		dHeight = DHeight;
		NM = Nm;
	}

	void SetArea() {

		cout << "Enter the size of the workspace (form: X_Y (Centimeters)): " << endl;
		cin >> XM >> YM;
	}

	Size GetSize(VideoCapture& cap) {

		dWidth = cap.get(CV_CAP_PROP_FRAME_WIDTH);
		dHeight = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

		Size frameSize(static_cast<int>(dWidth), static_cast<int>(dHeight));

		return frameSize;
	}

	void Ratio() {

		Rat = (XM * YM) / (dWidth * dHeight);
	}

	double Transform(int N) {

		NM = Rat * N;
		return NM;
	}
};

Mat Rendering(Mat &frame, vector<vector<Point> > contours, int rectcentreX, int rectcentreY, int RCMX, int RCMY,
	float distance, int CLX, int CLY, Rect &minRect, size_t i, float Rwidth, float Rheight) {

	rectangle(frame, minRect, Scalar(0, 0, 255));
	circle(frame, Point(rectcentreX, rectcentreY), 1, (0, 0, 255), 3);
	if (i > 0) {
		line(frame, Point(RCMX, RCMY), Point(rectcentreX, rectcentreY), Scalar(0, 0, 255));
		putText(frame, format("D = %.3f Cm", distance), Point(CLX, CLY),
			FONT_HERSHEY_PLAIN, 1, Scalar(0, 255, 0));
	}
	putText(frame, format("W = %.3f Cm , H = %.3f Cm", Rwidth, Rheight), Point(minRect.x, minRect.y),
		FONT_HERSHEY_PLAIN, 1, Scalar(0, 255, 0));

	return frame;
}

int main(int argc, char** argv)
{
	VideoCapture cap(0);

	vector<vector<Point> > contours;

	Mat gray_image;
	Mat edge;
	Mat filter;
	Mat frame;

	Line line(0, 0, 0, 0, 0, 0, 0);
	Area area(0, 0, 0, 0, 0, 0, 0);

	area.SetArea();

	VideoWriter oVideoWriter("robot.avi", CV_FOURCC('F', 'L', 'V', '1'), 24, area.GetSize(cap));

	area.Ratio();

	Error1(cap, oVideoWriter);

	while (true)
	{

		Error2(cap, frame);

		findContours(Filter(frame, edge, filter, gray_image), contours, RETR_LIST, CHAIN_APPROX_SIMPLE);

		for (size_t i = 0; i < contours.size(); i++)
		{
			Rect minRect = boundingRect(contours[i]);

			line.Equality();

			if (minRect.width > 50 & minRect.height > 50 & minRect.width < 600 & minRect.height < 600)
			{
				line.RectCentre(minRect);
				line.Dist();
				line.CentreLine();
				Rendering(frame, contours, line.GetrectcentreX(), line.GetrectcentreY(), line.GetRCMX(), line.GetRCMY(), 
					area.Transform(line.Getdistance()), line.GetCLX(), 
					line.GetCLY(), minRect, i, area.Transform(minRect.width), area.Transform(minRect.height));
			}


		}
			oVideoWriter.write(frame); 
		
			imshow("Display", frame);

			waitKey(1);
	}
}
